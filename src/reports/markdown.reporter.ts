import { Finding, Severity } from "../findings/finding";
import { ReportingConfig } from "../core/config.loader";
import { sortByRisk } from "../findings/normalizer";
import { RiskEngine, Remediation } from "../findings/risk.engine";
import { AttackAnalyzer, SecurityVerdict } from "../findings/attack.analyzer";

export interface MarkdownReporterOptions {
  targetUrl: string;
  scanDuration?: number;
}

export class MarkdownReporter {
  private config: ReportingConfig;
  private riskEngine: RiskEngine;
  private attackAnalyzer: AttackAnalyzer;

  constructor(config: ReportingConfig) {
    this.config = config;
    this.riskEngine = new RiskEngine();
    this.attackAnalyzer = new AttackAnalyzer();
  }

  generate(findings: Finding[], options: MarkdownReporterOptions): string {
    const lines: string[] = [];
    const verdict = this.attackAnalyzer.generateVerdict(findings);

    // Header
    lines.push("# Security Scan Report");
    lines.push("");
    lines.push(`**Target:** ${options.targetUrl}`);
    lines.push(`**Generated:** ${new Date().toISOString()}`);
    if (options.scanDuration) {
      lines.push(`**Duration:** ${(options.scanDuration / 1000).toFixed(1)}s`);
    }
    lines.push("");

    // Security Verdict - THE KEY DECISION
    lines.push("## Security Verdict");
    lines.push("");
    lines.push(this.generateVerdictSection(verdict));
    lines.push("");

    // Executive Summary
    lines.push("## Executive Summary");
    lines.push("");
    lines.push(this.generateExecutiveSummary(findings, verdict));
    lines.push("");

    // Summary Table
    lines.push("## Findings Summary");
    lines.push("");
    lines.push(this.generateSummaryTable(findings));
    lines.push("");

    // Findings by Severity
    const sortedFindings = sortByRisk(findings);

    const criticalFindings = sortedFindings.filter((f) => f.severity === "CRITICAL");
    const highFindings = sortedFindings.filter((f) => f.severity === "HIGH");
    const mediumFindings = sortedFindings.filter((f) => f.severity === "MEDIUM");
    const lowFindings = sortedFindings.filter((f) => f.severity === "LOW");

    if (criticalFindings.length > 0) {
      lines.push("## Critical Findings");
      lines.push("");
      lines.push(this.generateFindingsSection(criticalFindings));
    }

    if (highFindings.length > 0) {
      lines.push("## High Severity Findings");
      lines.push("");
      lines.push(this.generateFindingsSection(highFindings));
    }

    if (mediumFindings.length > 0) {
      lines.push("## Medium Severity Findings");
      lines.push("");
      lines.push(this.generateFindingsSection(mediumFindings));
    }

    if (lowFindings.length > 0) {
      lines.push("## Low Severity Findings");
      lines.push("");
      lines.push(this.generateFindingsSection(lowFindings));
    }

    // Attack Surface Analysis
    if (findings.length > 0) {
      lines.push("## Attack Surface Analysis");
      lines.push("");
      lines.push(this.generateAttackSurfaceSection(findings));
      lines.push("");
    }

    // Attack Chains
    if (verdict.attackChains.length > 0) {
      lines.push("## Potential Attack Chains");
      lines.push("");
      lines.push(this.generateAttackChainsSection(verdict));
      lines.push("");
    }

    // Contextual Remediation
    lines.push("## Remediation Plan");
    lines.push("");
    lines.push(this.generateRemediationPlan(verdict));

    // Footer
    lines.push("---");
    lines.push("");
    lines.push("*Generated by Security Bot - Attack Feasibility Analyzer*");

    return lines.join("\n");
  }

  private generateVerdictSection(verdict: SecurityVerdict): string {
    const lines: string[] = [];

    // Big verdict box
    switch (verdict.verdict) {
      case "UNSAFE":
        lines.push("```");
        lines.push("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        lines.push("â•‘              â›”  UNSAFE TO DEPLOY  â›”                     â•‘");
        lines.push("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        lines.push("```");
        break;
      case "REVIEW_REQUIRED":
        lines.push("```");
        lines.push("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        lines.push("â•‘             âš ï¸  REVIEW REQUIRED  âš ï¸                       â•‘");
        lines.push("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        lines.push("```");
        break;
      case "SAFE":
        lines.push("```");
        lines.push("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        lines.push("â•‘              âœ…  SAFE TO DEPLOY  âœ…                       â•‘");
        lines.push("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
        lines.push("```");
        break;
    }

    lines.push("");
    lines.push(`**Reason:** ${verdict.reason}`);
    lines.push("");

    if (verdict.confirmedExploits.length > 0) {
      lines.push("### âš¡ Confirmed Exploits");
      lines.push("");
      lines.push("These vulnerabilities were **actively exploited** during testing:");
      lines.push("");
      for (const exploit of verdict.confirmedExploits) {
        lines.push(`- **${exploit.category}** on \`${exploit.endpoint || "application"}\``);
      }
      lines.push("");
    }

    return lines.join("\n");
  }

  private generateAttackSurfaceSection(findings: Finding[]): string {
    const lines: string[] = [];
    const correlations = this.attackAnalyzer.correlateByEndpoint(findings);

    lines.push("| Endpoint | Risk | Vulnerabilities | Attack Feasibility |");
    lines.push("|----------|------|-----------------|-------------------|");

    for (const corr of correlations.slice(0, 10)) {
      const riskPercent = Math.round(corr.combinedRisk * 100);
      const riskEmoji = riskPercent >= 70 ? "ğŸ”´" : riskPercent >= 50 ? "ğŸŸ " : riskPercent >= 30 ? "ğŸŸ¡" : "ğŸŸ¢";
      const vulnTypes = [...new Set(corr.findings.map(f => f.category))].slice(0, 2).join(", ");
      const feasibility = riskPercent >= 70 ? "High" : riskPercent >= 50 ? "Medium" : "Low";

      lines.push(`| \`${corr.endpoint}\` | ${riskEmoji} ${riskPercent}% | ${vulnTypes} | ${feasibility} |`);
    }

    return lines.join("\n");
  }

  private generateAttackChainsSection(verdict: SecurityVerdict): string {
    const lines: string[] = [];

    // Deduplicate chains
    const uniqueChains = new Map<string, typeof verdict.attackChains[0]>();
    for (const chain of verdict.attackChains) {
      if (!uniqueChains.has(chain.name)) {
        uniqueChains.set(chain.name, chain);
      }
    }

    for (const chain of uniqueChains.values()) {
      const impactEmoji = chain.impact === "critical" ? "ğŸ”´" : chain.impact === "high" ? "ğŸŸ " : "ğŸŸ¡";

      lines.push(`### ${impactEmoji} ${chain.name}`);
      lines.push("");
      lines.push(`**Likelihood:** ${chain.likelihood} | **Impact:** ${chain.impact}`);
      lines.push("");
      lines.push("**Attack Steps:**");
      for (let i = 0; i < chain.steps.length; i++) {
        lines.push(`${i + 1}. ${chain.steps[i]}`);
      }
      lines.push("");
    }

    return lines.join("\n");
  }

  private generateRemediationPlan(verdict: SecurityVerdict): string {
    const lines: string[] = [];

    if (verdict.recommendations.length === 0) {
      lines.push("No critical remediations required at this time.");
      return lines.join("\n");
    }

    lines.push("Prioritized fixes based on attack feasibility:");
    lines.push("");

    for (const rem of verdict.recommendations) {
      const priorityEmoji = rem.priority === "immediate" ? "ğŸš¨" :
                            rem.priority === "high" ? "âš ï¸" :
                            rem.priority === "medium" ? "ğŸ“‹" : "ğŸ“";

      lines.push(`### ${priorityEmoji} ${rem.finding.category}`);
      lines.push("");
      lines.push(`**Endpoint:** \`${rem.endpoint}\``);
      lines.push(`**Priority:** ${rem.priority.toUpperCase()}`);
      lines.push("");
      lines.push(`**Fix:** ${rem.specificFix}`);
      lines.push("");

      if (rem.codeExample) {
        lines.push("**Example:**");
        lines.push("```javascript");
        lines.push(rem.codeExample);
        lines.push("```");
        lines.push("");
      }
    }

    return lines.join("\n");
  }

  private generateExecutiveSummary(findings: Finding[], verdict: SecurityVerdict): string {
    const total = findings.length;

    if (total === 0) {
      return "No security vulnerabilities were detected during this scan. The application is safe to deploy.";
    }

    const lines: string[] = [];

    // Lead with the key question
    lines.push("### Is it safe to deploy?");
    lines.push("");

    switch (verdict.verdict) {
      case "UNSAFE":
        lines.push("**No.** Active exploitation was successful during testing. This application has confirmed security vulnerabilities that can be exploited by attackers.");
        break;
      case "REVIEW_REQUIRED":
        lines.push("**Not yet.** Significant security findings require review before deployment. While no active exploitation was confirmed, the risk profile requires security team sign-off.");
        break;
      case "SAFE":
        lines.push("**Yes.** No significant security issues were detected. The application meets security standards for deployment.");
        break;
    }

    lines.push("");

    // Key metrics
    lines.push("### Key Metrics");
    lines.push("");
    lines.push(`- **Total Findings:** ${total}`);
    lines.push(`- **Confirmed Exploits:** ${verdict.confirmedExploits.length}`);
    lines.push(`- **Critical Findings:** ${verdict.criticalFindings.length}`);
    lines.push(`- **Attack Chains Identified:** ${verdict.attackChains.length}`);

    // AI findings highlight
    const aiFindings = findings.filter(f => f.sources.includes("AI Security Tester"));
    if (aiFindings.length > 0) {
      lines.push(`- **AI-Confirmed Vulnerabilities:** ${aiFindings.length} (behavioral testing)`);
    }

    return lines.join("\n");
  }

  private generateSummaryTable(findings: Finding[]): string {
    const bySeverity: Record<Severity, number> = {
      CRITICAL: 0,
      HIGH: 0,
      MEDIUM: 0,
      LOW: 0,
    };

    const byCategory: Record<string, number> = {};

    for (const finding of findings) {
      bySeverity[finding.severity]++;
      byCategory[finding.category] = (byCategory[finding.category] || 0) + 1;
    }

    const lines: string[] = [];

    // Severity table
    lines.push("### By Severity");
    lines.push("");
    lines.push("| Severity | Count |");
    lines.push("|----------|-------|");
    lines.push(`| ğŸ”´ Critical | ${bySeverity.CRITICAL} |`);
    lines.push(`| ğŸŸ  High | ${bySeverity.HIGH} |`);
    lines.push(`| ğŸŸ¡ Medium | ${bySeverity.MEDIUM} |`);
    lines.push(`| ğŸŸ¢ Low | ${bySeverity.LOW} |`);
    lines.push(`| **Total** | **${findings.length}** |`);
    lines.push("");

    // Category table (top 10)
    const sortedCategories = Object.entries(byCategory)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    if (sortedCategories.length > 0) {
      lines.push("### By Category");
      lines.push("");
      lines.push("| Category | Count |");
      lines.push("|----------|-------|");
      for (const [category, count] of sortedCategories) {
        lines.push(`| ${category} | ${count} |`);
      }
      lines.push("");
    }

    return lines.join("\n");
  }

  private generateFindingsSection(findings: Finding[]): string {
    const lines: string[] = [];

    for (const finding of findings) {
      lines.push(`### ${this.getSeverityEmoji(finding.severity)} ${finding.title}`);
      lines.push("");
      lines.push(`**Category:** ${finding.category}`);
      lines.push(`**Risk Score:** ${finding.riskScore.toFixed(2)} (Exploitability: ${finding.exploitability.toFixed(2)}, Confidence: ${finding.confidence.toFixed(2)})`);

      if (finding.endpoint) {
        lines.push(`**Endpoint:** \`${finding.endpoint}\``);
      }

      // Highlight endpoint context for dynamic findings
      if (finding.endpointContext) {
        const ctx = finding.endpointContext;
        const flags: string[] = [];
        if (ctx.acceptsUserInput) flags.push("accepts user input");
        if (ctx.handlesData) flags.push("handles sensitive data");
        if (!ctx.requiresAuth) flags.push("no auth required");
        if (flags.length > 0) {
          lines.push(`**Endpoint Risk Factors:** ${flags.join(", ")}`);
        }
      }

      if (finding.cve) {
        lines.push(`**CVE:** [${finding.cve}](https://nvd.nist.gov/vuln/detail/${finding.cve})`);
      }

      if (finding.cwe) {
        lines.push(`**CWE:** ${finding.cwe}`);
      }

      if (finding.package) {
        lines.push(`**Package:** ${finding.package}@${finding.version || "unknown"}`);
        if (finding.fixedVersion) {
          lines.push(`**Fixed In:** ${finding.fixedVersion}`);
        }
      }

      // Highlight AI-detected findings with special indicator
      const isAIDetected = finding.sources.includes("AI Security Tester");
      if (isAIDetected) {
        lines.push(`**Sources:** ${finding.sources.join(", ")} ğŸ¤–`);
        lines.push(`> *AI-detected: This vulnerability was identified through intelligent security testing that understands endpoint semantics and business logic.*`);
      } else {
        lines.push(`**Sources:** ${finding.sources.join(", ")}`);
      }

      if (finding.deduplicated) {
        lines.push(`*Deduplicated from ${finding.duplicateCount + 1} occurrences*`);
      }

      if (this.config.includeEvidence && finding.evidence) {
        lines.push("");
        lines.push("**Evidence:**");
        lines.push("```");
        lines.push(finding.evidence.substring(0, 500));
        if (finding.evidence.length > 500) {
          lines.push("...[truncated]");
        }
        lines.push("```");
      }

      // Add remediation guidance
      const remediation = this.riskEngine.getRemediation(finding);
      lines.push("");
      lines.push(`**Remediation:** ${this.getPriorityEmoji(remediation.priority)} ${remediation.action}`);
      lines.push(`> ${remediation.details}`);
      lines.push(`> *Effort: ${remediation.effort}*`);

      if (finding.reference) {
        lines.push("");
        lines.push(`**Reference:** ${finding.reference}`);
      }

      lines.push("");
      lines.push("---");
      lines.push("");
    }

    return lines.join("\n");
  }

  private getPriorityEmoji(priority: Remediation["priority"]): string {
    switch (priority) {
      case "immediate":
        return "ğŸš¨";
      case "high":
        return "âš ï¸";
      case "medium":
        return "ğŸ“‹";
      case "low":
        return "ğŸ“";
    }
  }

  private generateRecommendations(findings: Finding[]): string {
    const lines: string[] = [];
    const recommendations = new Set<string>();

    for (const finding of findings) {
      const rec = this.getRecommendation(finding);
      if (rec) recommendations.add(rec);
    }

    if (recommendations.size === 0) {
      lines.push("No specific recommendations at this time.");
    } else {
      let i = 1;
      for (const rec of recommendations) {
        lines.push(`${i}. ${rec}`);
        i++;
      }
    }

    lines.push("");
    return lines.join("\n");
  }

  private getRecommendation(finding: Finding): string | null {
    const category = finding.category.toLowerCase();

    if (category.includes("injection") || category.includes("sql")) {
      return "Use parameterized queries and prepared statements to prevent injection attacks.";
    }
    if (category.includes("xss")) {
      return "Implement proper output encoding and Content Security Policy headers.";
    }
    if (category.includes("auth")) {
      return "Review and strengthen authentication mechanisms, implement MFA where possible.";
    }
    if (category.includes("access")) {
      return "Implement proper authorization checks at all API endpoints.";
    }
    if (category.includes("dependency") || category.includes("vulnerability")) {
      return "Update vulnerable dependencies to their latest secure versions.";
    }
    if (category.includes("secret") || category.includes("hardcoded")) {
      return "Remove hardcoded secrets and use environment variables or secret management tools.";
    }
    if (category.includes("misconfiguration") || category.includes("header")) {
      return "Review and harden security configurations, add missing security headers.";
    }

    return null;
  }

  private getSeverityEmoji(severity: Severity): string {
    switch (severity) {
      case "CRITICAL":
        return "ğŸ”´";
      case "HIGH":
        return "ğŸŸ ";
      case "MEDIUM":
        return "ğŸŸ¡";
      case "LOW":
        return "ğŸŸ¢";
    }
  }
}
