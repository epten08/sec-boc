import { Finding, Severity } from "../findings/finding";
import { ReportingConfig } from "../core/config.loader";
import { sortByRisk } from "../findings/normalizer";
import { RiskEngine, Remediation } from "../findings/risk.engine";

export interface MarkdownReporterOptions {
  targetUrl: string;
  scanDuration?: number;
}

export class MarkdownReporter {
  private config: ReportingConfig;
  private riskEngine: RiskEngine;

  constructor(config: ReportingConfig) {
    this.config = config;
    this.riskEngine = new RiskEngine();
  }

  generate(findings: Finding[], options: MarkdownReporterOptions): string {
    const lines: string[] = [];

    // Header
    lines.push("# Security Scan Report");
    lines.push("");
    lines.push(`**Target:** ${options.targetUrl}`);
    lines.push(`**Generated:** ${new Date().toISOString()}`);
    if (options.scanDuration) {
      lines.push(`**Duration:** ${(options.scanDuration / 1000).toFixed(1)}s`);
    }
    lines.push("");

    // Executive Summary
    lines.push("## Executive Summary");
    lines.push("");
    lines.push(this.generateExecutiveSummary(findings));
    lines.push("");

    // Summary Table
    lines.push("## Findings Summary");
    lines.push("");
    lines.push(this.generateSummaryTable(findings));
    lines.push("");

    // Findings by Severity
    const sortedFindings = sortByRisk(findings);

    const criticalFindings = sortedFindings.filter((f) => f.severity === "CRITICAL");
    const highFindings = sortedFindings.filter((f) => f.severity === "HIGH");
    const mediumFindings = sortedFindings.filter((f) => f.severity === "MEDIUM");
    const lowFindings = sortedFindings.filter((f) => f.severity === "LOW");

    if (criticalFindings.length > 0) {
      lines.push("## Critical Findings");
      lines.push("");
      lines.push(this.generateFindingsSection(criticalFindings));
    }

    if (highFindings.length > 0) {
      lines.push("## High Severity Findings");
      lines.push("");
      lines.push(this.generateFindingsSection(highFindings));
    }

    if (mediumFindings.length > 0) {
      lines.push("## Medium Severity Findings");
      lines.push("");
      lines.push(this.generateFindingsSection(mediumFindings));
    }

    if (lowFindings.length > 0) {
      lines.push("## Low Severity Findings");
      lines.push("");
      lines.push(this.generateFindingsSection(lowFindings));
    }

    // Recommendations
    lines.push("## Recommendations");
    lines.push("");
    lines.push(this.generateRecommendations(findings));

    // Footer
    lines.push("---");
    lines.push("");
    lines.push("*Generated by Security Bot*");

    return lines.join("\n");
  }

  private generateExecutiveSummary(findings: Finding[]): string {
    const total = findings.length;
    const critical = findings.filter((f) => f.severity === "CRITICAL").length;
    const high = findings.filter((f) => f.severity === "HIGH").length;

    if (total === 0) {
      return "No security vulnerabilities were detected during this scan. Continue to monitor and regularly scan your application.";
    }

    const lines: string[] = [];

    if (critical > 0) {
      lines.push(
        `**丘멆잺 CRITICAL:** ${critical} critical vulnerabilit${critical === 1 ? "y" : "ies"} found requiring immediate attention.`
      );
    }

    if (high > 0) {
      lines.push(
        `**游댮 HIGH:** ${high} high severity issue${high === 1 ? "" : "s"} should be addressed promptly.`
      );
    }

    lines.push("");
    lines.push(
      `A total of **${total}** security finding${total === 1 ? "" : "s"} were identified across the scanned components.`
    );

    // Risk assessment
    const avgRisk = findings.reduce((sum, f) => sum + f.riskScore, 0) / findings.length;
    let riskLevel = "Low";
    if (avgRisk > 0.7) riskLevel = "Critical";
    else if (avgRisk > 0.5) riskLevel = "High";
    else if (avgRisk > 0.3) riskLevel = "Medium";

    lines.push("");
    lines.push(`**Overall Risk Level:** ${riskLevel} (average risk score: ${avgRisk.toFixed(2)})`);

    return lines.join("\n");
  }

  private generateSummaryTable(findings: Finding[]): string {
    const bySeverity: Record<Severity, number> = {
      CRITICAL: 0,
      HIGH: 0,
      MEDIUM: 0,
      LOW: 0,
    };

    const byCategory: Record<string, number> = {};

    for (const finding of findings) {
      bySeverity[finding.severity]++;
      byCategory[finding.category] = (byCategory[finding.category] || 0) + 1;
    }

    const lines: string[] = [];

    // Severity table
    lines.push("### By Severity");
    lines.push("");
    lines.push("| Severity | Count |");
    lines.push("|----------|-------|");
    lines.push(`| 游댮 Critical | ${bySeverity.CRITICAL} |`);
    lines.push(`| 游 High | ${bySeverity.HIGH} |`);
    lines.push(`| 游리 Medium | ${bySeverity.MEDIUM} |`);
    lines.push(`| 游릭 Low | ${bySeverity.LOW} |`);
    lines.push(`| **Total** | **${findings.length}** |`);
    lines.push("");

    // Category table (top 10)
    const sortedCategories = Object.entries(byCategory)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    if (sortedCategories.length > 0) {
      lines.push("### By Category");
      lines.push("");
      lines.push("| Category | Count |");
      lines.push("|----------|-------|");
      for (const [category, count] of sortedCategories) {
        lines.push(`| ${category} | ${count} |`);
      }
      lines.push("");
    }

    return lines.join("\n");
  }

  private generateFindingsSection(findings: Finding[]): string {
    const lines: string[] = [];

    for (const finding of findings) {
      lines.push(`### ${this.getSeverityEmoji(finding.severity)} ${finding.title}`);
      lines.push("");
      lines.push(`**Category:** ${finding.category}`);
      lines.push(`**Risk Score:** ${finding.riskScore.toFixed(2)} (Exploitability: ${finding.exploitability.toFixed(2)}, Confidence: ${finding.confidence.toFixed(2)})`);

      if (finding.endpoint) {
        lines.push(`**Endpoint:** \`${finding.endpoint}\``);
      }

      // Highlight endpoint context for dynamic findings
      if (finding.endpointContext) {
        const ctx = finding.endpointContext;
        const flags: string[] = [];
        if (ctx.acceptsUserInput) flags.push("accepts user input");
        if (ctx.handlesData) flags.push("handles sensitive data");
        if (!ctx.requiresAuth) flags.push("no auth required");
        if (flags.length > 0) {
          lines.push(`**Endpoint Risk Factors:** ${flags.join(", ")}`);
        }
      }

      if (finding.cve) {
        lines.push(`**CVE:** [${finding.cve}](https://nvd.nist.gov/vuln/detail/${finding.cve})`);
      }

      if (finding.cwe) {
        lines.push(`**CWE:** ${finding.cwe}`);
      }

      if (finding.package) {
        lines.push(`**Package:** ${finding.package}@${finding.version || "unknown"}`);
        if (finding.fixedVersion) {
          lines.push(`**Fixed In:** ${finding.fixedVersion}`);
        }
      }

      // Highlight AI-detected findings with special indicator
      const isAIDetected = finding.sources.includes("AI Security Tester");
      if (isAIDetected) {
        lines.push(`**Sources:** ${finding.sources.join(", ")} 游뱄`);
        lines.push(`> *AI-detected: This vulnerability was identified through intelligent security testing that understands endpoint semantics and business logic.*`);
      } else {
        lines.push(`**Sources:** ${finding.sources.join(", ")}`);
      }

      if (finding.deduplicated) {
        lines.push(`*Deduplicated from ${finding.duplicateCount + 1} occurrences*`);
      }

      if (this.config.includeEvidence && finding.evidence) {
        lines.push("");
        lines.push("**Evidence:**");
        lines.push("```");
        lines.push(finding.evidence.substring(0, 500));
        if (finding.evidence.length > 500) {
          lines.push("...[truncated]");
        }
        lines.push("```");
      }

      // Add remediation guidance
      const remediation = this.riskEngine.getRemediation(finding);
      lines.push("");
      lines.push(`**Remediation:** ${this.getPriorityEmoji(remediation.priority)} ${remediation.action}`);
      lines.push(`> ${remediation.details}`);
      lines.push(`> *Effort: ${remediation.effort}*`);

      if (finding.reference) {
        lines.push("");
        lines.push(`**Reference:** ${finding.reference}`);
      }

      lines.push("");
      lines.push("---");
      lines.push("");
    }

    return lines.join("\n");
  }

  private getPriorityEmoji(priority: Remediation["priority"]): string {
    switch (priority) {
      case "immediate":
        return "游뚿";
      case "high":
        return "丘멆잺";
      case "medium":
        return "游늶";
      case "low":
        return "游닇";
    }
  }

  private generateRecommendations(findings: Finding[]): string {
    const lines: string[] = [];
    const recommendations = new Set<string>();

    for (const finding of findings) {
      const rec = this.getRecommendation(finding);
      if (rec) recommendations.add(rec);
    }

    if (recommendations.size === 0) {
      lines.push("No specific recommendations at this time.");
    } else {
      let i = 1;
      for (const rec of recommendations) {
        lines.push(`${i}. ${rec}`);
        i++;
      }
    }

    lines.push("");
    return lines.join("\n");
  }

  private getRecommendation(finding: Finding): string | null {
    const category = finding.category.toLowerCase();

    if (category.includes("injection") || category.includes("sql")) {
      return "Use parameterized queries and prepared statements to prevent injection attacks.";
    }
    if (category.includes("xss")) {
      return "Implement proper output encoding and Content Security Policy headers.";
    }
    if (category.includes("auth")) {
      return "Review and strengthen authentication mechanisms, implement MFA where possible.";
    }
    if (category.includes("access")) {
      return "Implement proper authorization checks at all API endpoints.";
    }
    if (category.includes("dependency") || category.includes("vulnerability")) {
      return "Update vulnerable dependencies to their latest secure versions.";
    }
    if (category.includes("secret") || category.includes("hardcoded")) {
      return "Remove hardcoded secrets and use environment variables or secret management tools.";
    }
    if (category.includes("misconfiguration") || category.includes("header")) {
      return "Review and harden security configurations, add missing security headers.";
    }

    return null;
  }

  private getSeverityEmoji(severity: Severity): string {
    switch (severity) {
      case "CRITICAL":
        return "游댮";
      case "HIGH":
        return "游";
      case "MEDIUM":
        return "游리";
      case "LOW":
        return "游릭";
    }
  }
}
